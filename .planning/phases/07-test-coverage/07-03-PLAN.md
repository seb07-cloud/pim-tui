---
phase: 07-test-coverage
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/ui/update_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "State transitions from StateLoading to StateNormal are testable"
    - "Key message handling produces expected state changes"
    - "Error states are reached on errMsg"
  artifacts:
    - path: "internal/ui/update_test.go"
      provides: "Tests for Model.Update state transitions"
      min_lines: 100
  key_links:
    - from: "internal/ui/update_test.go"
      to: "internal/ui/model.go"
      via: "calls Model.Update with messages"
      pattern: "Update"
---

<objective>
Add unit tests for UI model state transitions using Bubbletea testing patterns.

Purpose: Close gap #2 from VERIFICATION.md - "UI state machine has tests for all valid transitions"
Output: update_test.go with tests for key state transitions in Model.Update.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-test-coverage/07-01-SUMMARY.md

# Source files to test:
@internal/ui/model.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UI state transition tests</name>
  <files>internal/ui/update_test.go</files>
  <action>
Create tests for UI Model.Update state transitions:

1. **Create test model helper:**
   - Function to create Model in specific initial state
   - Use NewModel with test config, then set state directly

2. **TestUpdateStateTransitions** - table-driven:
   Test key message → state changes:

   | Initial State | Message | Expected State | Notes |
   |--------------|---------|----------------|-------|
   | StateLoading | clientReadyMsg | StateLoading | Still loading (triggers tenant load) |
   | StateLoading | tenantLoadedMsg | StateLoading | Still loading (triggers role load) |
   | StateLoading | rolesLoadedMsg + groupsLoaded | StateNormal | All data loaded |
   | StateNormal | errMsg | StateError | Error display |
   | StateNormal | tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'?'}} | StateHelp | Help view |
   | StateHelp | tea.KeyMsg{Type: tea.KeyEsc} | StateNormal | Exit help |

3. **TestUpdateKeyHandling** - test key navigation:
   - 'j'/'k' in StateNormal → cursor moves (via internal state change)
   - Tab key → activeTab changes
   - Enter on role → triggers StateConfirm

4. **TestUpdateAsyncMessages**:
   - rolesLoadedMsg with data → roles populated, rolesLoaded = true
   - groupsLoadedMsg with data → groups populated, groupsLoaded = true
   - errMsg → state becomes StateError, err field set

**Bubbletea testing pattern:**
```go
func TestUpdateStateTransitions(t *testing.T) {
    tests := []struct {
        name          string
        initialState  State
        msg           tea.Msg
        wantState     State
    }{
        {
            name:         "error message sets error state",
            initialState: StateNormal,
            msg:          errMsg{err: fmt.Errorf("test error"), source: "test"},
            wantState:    StateError,
        },
        // ... more cases
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            cfg := config.Default()
            m := NewModel(cfg, "test")
            m.state = tt.initialState

            newModel, _ := m.Update(tt.msg)
            got := newModel.(Model)

            if got.state != tt.wantState {
                t.Errorf("state = %v, want %v", got.state, tt.wantState)
            }
        })
    }
}
```

**Note:** Focus on testable state transitions. Some transitions require complex setup (loading all data before StateNormal). Test the transitions that can be isolated.
  </action>
  <verify>go test -v ./internal/ui/... -run "TestUpdate" passes</verify>
  <done>update_test.go exists with passing tests for Model.Update state transitions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test -v ./internal/ui/...` passes all tests
- [ ] Tests verify state transitions from messages
- [ ] Error state handling is tested
- [ ] No new warnings or errors introduced
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Model.Update state transitions have test coverage
- Key message handling is verified
</success_criteria>

<output>
After completion, create `.planning/phases/07-test-coverage/07-03-SUMMARY.md`
</output>
