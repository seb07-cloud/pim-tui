---
phase: 07-test-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/azure/client_test.go
  - internal/azure/types_test.go
autonomous: true

must_haves:
  truths:
    - "Azure client HTTP requests can be tested with mocked responses"
    - "StatusFromExpiry function has tests for all edge cases"
    - "Tests pass with go test ./..."
  artifacts:
    - path: "internal/azure/client_test.go"
      provides: "HTTP mock tests for Azure client"
      contains: "httptest.NewServer"
    - path: "internal/azure/types_test.go"
      provides: "Unit tests for type helpers"
      contains: "TestStatusFromExpiry"
  key_links:
    - from: "test"
      to: "mock server"
      via: "httptest.NewServer"
---

<objective>
Add unit tests for Azure client methods with mocked HTTP responses.

Purpose: Enable safe refactoring with regression detection. Start with high-value, low-complexity tests.
Output: Test files for Azure package with meaningful coverage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/TESTING.md
@.planning/codebase/CONCERNS.md

@internal/azure/types.go
@internal/azure/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types_test.go with StatusFromExpiry tests</name>
  <files>internal/azure/types_test.go</files>
  <action>
    Create table-driven tests for StatusFromExpiry:

    ```go
    package azure

    import (
        "testing"
        "time"
    )

    func TestStatusFromExpiry(t *testing.T) {
        tests := []struct {
            name     string
            expiry   *time.Time
            expected ActivationStatus
        }{
            {
                name:     "nil expiry returns inactive",
                expiry:   nil,
                expected: StatusInactive,
            },
            {
                name:     "expired returns inactive",
                expiry:   timePtr(time.Now().Add(-1 * time.Hour)),
                expected: StatusInactive,
            },
            {
                name:     "expiring in 10 minutes returns expiring soon",
                expiry:   timePtr(time.Now().Add(10 * time.Minute)),
                expected: StatusExpiringSoon,
            },
            {
                name:     "expiring in 2 hours returns active",
                expiry:   timePtr(time.Now().Add(2 * time.Hour)),
                expected: StatusActive,
            },
            {
                name:     "expiring in exactly 30 minutes returns expiring soon",
                expiry:   timePtr(time.Now().Add(30 * time.Minute)),
                expected: StatusExpiringSoon,
            },
            {
                name:     "expiring in 31 minutes returns active",
                expiry:   timePtr(time.Now().Add(31 * time.Minute)),
                expected: StatusActive,
            },
        }

        for _, tt := range tests {
            t.Run(tt.name, func(t *testing.T) {
                got := StatusFromExpiry(tt.expiry)
                if got != tt.expected {
                    t.Errorf("StatusFromExpiry() = %v, want %v", got, tt.expected)
                }
            })
        }
    }

    func timePtr(t time.Time) *time.Time {
        return &t
    }

    func TestActivationStatus_IsActive(t *testing.T) {
        tests := []struct {
            status   ActivationStatus
            expected bool
        }{
            {StatusInactive, false},
            {StatusActive, true},
            {StatusExpiringSoon, true},
            {StatusPending, false},
        }

        for _, tt := range tests {
            t.Run(tt.status.String(), func(t *testing.T) {
                if got := tt.status.IsActive(); got != tt.expected {
                    t.Errorf("IsActive() = %v, want %v", got, tt.expected)
                }
            })
        }
    }
    ```
  </action>
  <verify>go test ./internal/azure/... passes</verify>
  <done>StatusFromExpiry and IsActive have comprehensive tests</done>
</task>

<task type="auto">
  <name>Task 2: Create client_test.go with HTTP mock tests</name>
  <files>internal/azure/client_test.go</files>
  <action>
    Create tests using httptest.NewServer to mock API responses:

    ```go
    package azure

    import (
        "context"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "testing"
    )

    func TestClient_GetCurrentUser(t *testing.T) {
        // Create mock server
        server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            if r.URL.Path != "/v1.0/me" {
                t.Errorf("unexpected path: %s", r.URL.Path)
            }

            response := map[string]string{"id": "test-user-id"}
            json.NewEncoder(w).Encode(response)
        }))
        defer server.Close()

        // Create client with mock server URL
        client := &Client{
            httpClient: server.Client(),
            cred:       &mockCredential{},
        }

        // Override graphBaseURL for test
        // Note: This requires refactoring to inject base URL
        // For now, test the parsing logic separately

        // Test user ID caching
        client.userID = "cached-id"
        ctx := context.Background()

        id, err := client.GetCurrentUser(ctx)
        if err != nil {
            t.Fatalf("GetCurrentUser() error = %v", err)
        }
        if id != "cached-id" {
            t.Errorf("GetCurrentUser() = %v, want cached-id", id)
        }
    }

    // mockCredential implements azcore.TokenCredential for testing
    type mockCredential struct{}

    func (m *mockCredential) GetToken(ctx context.Context, opts policy.TokenRequestOptions) (azcore.AccessToken, error) {
        return azcore.AccessToken{
            Token:     "mock-token",
            ExpiresOn: time.Now().Add(1 * time.Hour),
        }, nil
    }

    func TestClient_GetTenant_Parsing(t *testing.T) {
        responseJSON := `{
            "value": [{
                "id": "tenant-123",
                "displayName": "Test Tenant"
            }]
        }`

        server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Write([]byte(responseJSON))
        }))
        defer server.Close()

        // Test JSON parsing directly
        var result struct {
            Value []struct {
                ID          string `json:"id"`
                DisplayName string `json:"displayName"`
            } `json:"value"`
        }

        if err := json.Unmarshal([]byte(responseJSON), &result); err != nil {
            t.Fatalf("Failed to parse: %v", err)
        }

        if len(result.Value) != 1 {
            t.Fatalf("Expected 1 value, got %d", len(result.Value))
        }

        if result.Value[0].ID != "tenant-123" {
            t.Errorf("ID = %v, want tenant-123", result.Value[0].ID)
        }
    }
    ```

    Note: Full HTTP integration tests require dependency injection for base URLs.
    Start with testing parsing logic and caching behavior.
  </action>
  <verify>go test ./internal/azure/... passes</verify>
  <done>Client tests with mocks created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./internal/azure/...` passes
- [ ] types_test.go exists with StatusFromExpiry tests
- [ ] client_test.go exists with basic tests
- [ ] No test failures
</verification>

<success_criteria>
- All tasks completed
- Tests pass
- Coverage started for Azure package
</success_criteria>

<output>
After completion, create `.planning/phases/07-test-coverage/07-01-SUMMARY.md`
</output>
