---
phase: 07-test-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/azure/types_test.go
  - internal/config/config_test.go
  - internal/ui/model_test.go
  - internal/ui/views_test.go
autonomous: true

must_haves:
  truths:
    - "go test ./... runs and produces output"
    - "Azure status calculation logic is tested"
    - "Config loading handles missing, valid, and invalid files"
    - "UI helper functions for cursor and validation are tested"
    - "All tests pass"
  artifacts:
    - path: "internal/azure/types_test.go"
      provides: "Tests for StatusFromExpiry, ActivationStatus.String(), IsActive()"
      min_lines: 50
    - path: "internal/config/config_test.go"
      provides: "Tests for Default(), Load() scenarios"
      min_lines: 60
    - path: "internal/ui/model_test.go"
      provides: "Tests for clampCursor, indexOf, parseLogLevel, validateJustification"
      min_lines: 80
    - path: "internal/ui/views_test.go"
      provides: "Tests for formatDuration, formatCompactDuration, truncate"
      min_lines: 40
  key_links:
    - from: "internal/azure/types_test.go"
      to: "internal/azure/types.go"
      via: "imports and tests StatusFromExpiry"
      pattern: "StatusFromExpiry"
    - from: "internal/config/config_test.go"
      to: "internal/config/config.go"
      via: "tests Load() with temp files"
      pattern: "Load\\(\\)"
    - from: "internal/ui/model_test.go"
      to: "internal/ui/model.go"
      via: "tests validateJustification"
      pattern: "validateJustification"
---

<objective>
Add unit test coverage for Azure types, config loading, and UI helper functions.

Purpose: Establish test foundation for critical logic paths, enabling confident future refactoring.
Output: Test files covering pure functions with >70% coverage on target packages.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/TESTING.md
@.planning/codebase/CONVENTIONS.md

# Source files to test:
@internal/azure/types.go
@internal/config/config.go
@internal/ui/model.go
@internal/ui/views.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Azure types tests</name>
  <files>internal/azure/types_test.go</files>
  <action>
Create table-driven tests for pure functions in internal/azure/types.go:

1. **TestStatusFromExpiry** - table-driven with cases:
   - nil expiry → StatusInactive
   - expiry in far future (>30min) → StatusActive
   - expiry in <30min → StatusExpiringSoon
   - expiry in past → test edge case

2. **TestActivationStatus_String** - all enum values:
   - StatusActive → "Active"
   - StatusExpiringSoon → "Expiring Soon"
   - StatusPending → "Pending"
   - StatusInactive → "Inactive"

3. **TestActivationStatus_IsActive** - truth table:
   - StatusActive → true
   - StatusExpiringSoon → true
   - StatusPending → false
   - StatusInactive → false

Use standard Go testing patterns:
- Package: `package azure` (same package for internal access)
- Helper: `timePtr(t time.Time) *time.Time` for creating test times
- Table-driven tests with descriptive names
  </action>
  <verify>go test -v ./internal/azure/... passes with all tests</verify>
  <done>types_test.go exists with passing tests for StatusFromExpiry and ActivationStatus methods</done>
</task>

<task type="auto">
  <name>Task 2: Create config loading tests</name>
  <files>internal/config/config_test.go</files>
  <action>
Create tests for config loading in internal/config/config.go:

1. **TestDefault** - verify default config values:
   - DefaultDuration is 4
   - DurationPresets is [1, 2, 4, 8]
   - LogLevel is "info"
   - AutoRefreshInterval is 60
   - AutoRefreshEnabled is true
   - Theme colors are set

2. **TestDefaultTheme** - verify theme defaults:
   - ColorActive is "#00ff00"
   - ColorExpiring is "#ffff00"
   - etc.

3. **TestLoad_MissingFile** - verify returns defaults when file doesn't exist:
   - Create temp dir with no config file
   - Temporarily set XDG config dir (platform-specific)
   - Verify Load() returns defaults without error

4. **TestLoad_ValidFile** - verify parses valid YAML:
   - Create temp config file with valid YAML
   - Verify values are loaded correctly
   - Verify partial config merges with defaults

5. **TestLoad_InvalidYAML** - verify handles invalid YAML:
   - Create temp config file with invalid YAML syntax
   - Verify Load() returns error

Use t.TempDir() for creating temporary test directories.
Use os.WriteFile for creating test config files.
  </action>
  <verify>go test -v ./internal/config/... passes with all tests</verify>
  <done>config_test.go exists with passing tests for Default(), DefaultTheme(), and Load() scenarios</done>
</task>

<task type="auto">
  <name>Task 3: Create UI helper function tests</name>
  <files>internal/ui/model_test.go, internal/ui/views_test.go</files>
  <action>
Create tests for pure functions in internal/ui/:

**model_test.go:**

1. **TestClampCursor** - table-driven:
   - cursor=0, delta=-1, length=5 → 0 (can't go below 0)
   - cursor=4, delta=1, length=5 → 4 (can't exceed length-1)
   - cursor=2, delta=-1, length=5 → 1 (normal movement)
   - cursor=2, delta=1, length=5 → 3 (normal movement)
   - cursor=0, delta=0, length=0 → 0 (empty list edge case)

2. **TestIndexOf** - table-driven:
   - [1,2,4,8], 4 → 2
   - [1,2,4,8], 1 → 0
   - [1,2,4,8], 8 → 3
   - [1,2,4,8], 5 → 0 (not found returns 0)
   - [], 1 → 0 (empty slice)

3. **TestParseLogLevel** - table-driven:
   - "debug" → LogDebug
   - "error" → LogError
   - "info" → LogInfo
   - "" → LogInfo (default)
   - "unknown" → LogInfo (default)

4. **TestValidateJustification** - table-driven:
   - "valid reason" → ("valid reason", nil)
   - "" → ("", error "required")
   - "   " → ("", error "required") (whitespace only)
   - string with 501 chars → error "exceeds 500"
   - string with control char \x00 → error "invalid control"
   - string with DEL char \x7f → error "invalid control"
   - "reason\twith\ttabs" → valid (tabs allowed)

**views_test.go:**

1. **TestFormatDuration** - table-driven:
   - 30 minutes → "30m"
   - 1 hour → "1h"
   - 1.5 hours → "1h30m"
   - 2 hours → "2h"

2. **TestFormatCompactDuration** - table-driven:
   - 30 seconds → "<1m"
   - 45 minutes → "45m"
   - 1 hour → "1h"
   - 2h30m → "2h30m"

3. **TestTruncate** - table-driven:
   - "short", 10 → "short"
   - "this is a long string", 10 → "this is..."
   - "exactly10!", 10 → "exactly10!"

Use same package (package ui) for internal function access.
  </action>
  <verify>go test -v ./internal/ui/... passes with all tests</verify>
  <done>model_test.go and views_test.go exist with passing tests for all helper functions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./...` passes all tests
- [ ] `go test -cover ./internal/azure/...` shows coverage for types.go
- [ ] `go test -cover ./internal/config/...` shows coverage for config.go
- [ ] `go test -cover ./internal/ui/...` shows coverage for tested functions
- [ ] No new warnings or errors introduced
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Test files follow Go conventions (table-driven, descriptive names)
- Tests cover edge cases (empty lists, nil values, boundary conditions)
- `go test ./...` passes with meaningful coverage
  </success_criteria>

<output>
After completion, create `.planning/phases/07-test-coverage/07-01-SUMMARY.md`
</output>
