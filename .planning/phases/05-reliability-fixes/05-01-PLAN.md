---
phase: 05-reliability-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/azure/pim.go
  - internal/azure/groups.go
  - internal/azure/lighthouse.go
autonomous: true

must_haves:
  truths:
    - "No data races detected when running with -race flag"
    - "Group activation uses actual roleDefinitionId from API response"
    - "All API errors are logged with context"
  artifacts:
    - path: "internal/azure/groups.go"
      provides: "RoleDefinitionId stored in Group struct and used in activation"
      contains: "RoleDefinitionId"
    - path: "internal/azure/pim.go"
      provides: "Race-safe parallel fetching"
    - path: "internal/azure/groups.go"
      provides: "Race-safe parallel fetching"
  key_links:
    - from: "GetEligibleGroups"
      to: "Group.RoleDefinitionId"
      via: "stores roleDefinitionId from API"
    - from: "ActivateGroup"
      to: "Group.RoleDefinitionId"
      via: "uses stored roleDefinitionId"
---

<objective>
Fix race conditions in parallel goroutines and correct the hardcoded roleDefinitionId issue.

Purpose: Ensure thread-safe data access and correct group activation for all role types.
Output: Race-free code with proper roleDefinitionId handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

@internal/azure/pim.go
@internal/azure/groups.go
@internal/azure/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix potential race conditions in GetRoles and GetGroups</name>
  <files>internal/azure/pim.go, internal/azure/groups.go</files>
  <action>
    The current pattern uses separate error variables per goroutine, which is technically safe but fragile:
    ```go
    var eligibleErr, activeErr error
    go func() {
        eligible, eligibleErr = c.GetEligibleRoles(ctx)
    }()
    go func() {
        active, activeErr = c.GetActiveRoles(ctx)
    }()
    ```

    Replace with proper closure pattern that captures results locally:
    ```go
    type result struct {
        eligible []Role
        active   map[string]*time.Time
        err      error
    }

    eligibleCh := make(chan result, 1)
    activeCh := make(chan result, 1)

    go func() {
        roles, err := c.GetEligibleRoles(ctx)
        eligibleCh <- result{eligible: roles, err: err}
    }()
    go func() {
        active, err := c.GetActiveRoles(ctx)
        activeCh <- result{active: active, err: err}
    }()

    eligibleResult := <-eligibleCh
    activeResult := <-activeCh

    if eligibleResult.err != nil {
        return nil, eligibleResult.err
    }
    if activeResult.err != nil {
        return nil, activeResult.err
    }
    ```

    Apply this pattern to:
    - pim.go: GetRoles (lines 106-139)
    - groups.go: GetGroups (lines 154-187)
  </action>
  <verify>go build -race ./... succeeds with no warnings</verify>
  <done>Race-safe parallel fetching implemented</done>
</task>

<task type="auto">
  <name>Task 2: Store and use actual roleDefinitionId for groups</name>
  <files>internal/azure/groups.go, internal/azure/types.go</files>
  <action>
    1. Add RoleDefinitionId field to Group struct in types.go:
       ```go
       type Group struct {
           ID              string
           DisplayName     string
           Description     string            // "Member" or "Owner"
           RoleDefinitionId string           // Actual roleDefinitionId from API
           Status          ActivationStatus
           ExpiresAt       *time.Time
           MaxDuration     time.Duration
       }
       ```

    2. In GetEligibleGroups (groups.go), extract roleDefinitionId from API response:
       The API response includes `roleDefinition.id` which is the actual roleDefinitionId.

       Current code (around line 90):
       ```go
       groups = append(groups, Group{
           ID:          g.ResourceID,
           DisplayName: displayName,
           Description: g.RoleDefinition.DisplayName,
           Status:      StatusInactive,
           MaxDuration: 8 * time.Hour,
       })
       ```

       Change to:
       ```go
       groups = append(groups, Group{
           ID:               g.ResourceID,
           DisplayName:      displayName,
           Description:      g.RoleDefinition.DisplayName,
           RoleDefinitionId: g.RoleDefinition.ID,  // Store actual ID
           Status:           StatusInactive,
           MaxDuration:      8 * time.Hour,
       })
       ```

    3. Modify ActivateGroup and DeactivateGroup to accept roleDefinitionId:
       ```go
       func (c *Client) ActivateGroup(ctx context.Context, groupID, roleDefinitionId, justification string, duration time.Duration) error {
           // Use roleDefinitionId instead of hardcoded "member"
           body := map[string]interface{}{
               "resourceId":       groupID,
               "roleDefinitionId": roleDefinitionId,
               // ...
           }
       }
       ```

    4. Update call sites in internal/ui/model.go to pass group.RoleDefinitionId
  </action>
  <verify>go build ./... succeeds, grep "\"member\"" internal/azure/groups.go returns no activation-related matches</verify>
  <done>Group activation uses correct roleDefinitionId from API</done>
</task>

<task type="auto">
  <name>Task 3: Add error context to API error logging</name>
  <files>internal/azure/client.go, internal/azure/lighthouse.go</files>
  <action>
    Improve error messages to include context:

    1. In graphRequest, pimRequest, armRequest - enhance error formatting:
       ```go
       if resp.StatusCode >= 400 {
           return nil, fmt.Errorf("API error: method=%s url=%s status=%d body=%s",
               method, url, resp.StatusCode, string(respBody))
       }
       ```

    2. For rate-limited requests, include attempt count:
       ```go
       return nil, fmt.Errorf("API failed after %d retries: last status=%d url=%s",
           maxRetries, lastStatus, url)
       ```

    This makes debugging production issues much easier.
  </action>
  <verify>go build ./... succeeds</verify>
  <done>API errors include full context for debugging</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go build -race ./...` succeeds with no warnings
- [ ] Group struct has RoleDefinitionId field
- [ ] ActivateGroup uses passed roleDefinitionId (not hardcoded)
- [ ] Error messages include method, URL, status code
</verification>

<success_criteria>
- All tasks completed
- No race conditions detected
- Group activation uses correct roleDefinitionId
- API errors are informative
</success_criteria>

<output>
After completion, create `.planning/phases/05-reliability-fixes/05-01-SUMMARY.md`
</output>
