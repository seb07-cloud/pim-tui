---
phase: 03-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/azure/lighthouse.go
  - internal/azure/pim.go
  - internal/azure/groups.go
  - internal/azure/client.go
autonomous: true

must_haves:
  truths:
    - "Tenant names are fetched once per unique tenant ID, not per subscription"
    - "Subscription list loads faster when multiple subscriptions share same tenant"
    - "Users with 100+ roles see all data (pagination works)"
    - "Users with 100+ groups see all data (pagination works)"
  artifacts:
    - path: "internal/azure/lighthouse.go"
      provides: "Tenant name caching logic"
      contains: "tenantCache"
    - path: "internal/azure/pim.go"
      provides: "Pagination for PIM roles"
      contains: "@odata.nextLink"
    - path: "internal/azure/groups.go"
      provides: "Pagination for PIM groups"
      contains: "@odata.nextLink"
  key_links:
    - from: "GetLighthouseSubscriptions"
      to: "tenant cache map"
      via: "build cache before subscription loop"
      pattern: "tenantCache.*make\\(map"
    - from: "pimRequest"
      to: "pagination loop"
      via: "follow nextLink until empty"
      pattern: "nextLink.*!="
---

<objective>
Optimize performance by caching tenant names and adding pagination support.

Purpose: Reduce API calls for subscriptions sharing tenants; handle users with 100+ items gracefully.
Output: Faster subscription loading, complete data for power users with many roles/groups.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

# Source files to modify:
@internal/azure/lighthouse.go
@internal/azure/pim.go
@internal/azure/groups.go
@internal/azure/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tenant name caching to GetLighthouseSubscriptions</name>
  <files>internal/azure/lighthouse.go</files>
  <action>
Refactor GetLighthouseSubscriptions to cache tenant names efficiently:

1. After building subMap from eligible roles, collect unique tenant IDs:
   - For each subscription, call getSubscriptionDetails to get tenantID
   - Store subID -> tenantID mapping
   - Collect unique tenant IDs into a set

2. Fetch tenant names for unique tenant IDs only (in parallel):
   - Create tenantCache map[string]string
   - For each unique tenantID, call getTenantNameByID
   - Store result in tenantCache

3. Apply cached names to subscriptions:
   - For each subscription, lookup its tenantID
   - Use tenantCache to get the name
   - Set TenantID and TenantName on the subscription

This changes the current pattern from:
- For each subscription: fetch details + fetch tenant name (N*2 calls if N subs)

To:
- For each subscription: fetch details (N calls)
- For each unique tenant: fetch name (M calls where M <= N)

Example: 10 subscriptions in 2 tenants = 10+2 = 12 calls instead of 10+10 = 20 calls
  </action>
  <verify>go build ./... succeeds; go vet ./... reports no issues</verify>
  <done>GetLighthouseSubscriptions fetches tenant names once per unique tenant ID</done>
</task>

<task type="auto">
  <name>Task 2: Add pagination to PIM and Graph API requests</name>
  <files>internal/azure/pim.go, internal/azure/groups.go, internal/azure/client.go</files>
  <action>
Add @odata.nextLink pagination handling to API responses:

1. Update response types to include NextLink:
   - In pim.go: Add `NextLink string \`json:"@odata.nextLink"\`` to pimRoleResponse
   - In groups.go: Add `NextLink string \`json:"@odata.nextLink"\`` to pimGroupResponse

2. Create pagination helper in client.go:
   ```go
   // pimRequestPaginated follows nextLink to fetch all pages
   func (c *Client) pimRequestPaginated(ctx context.Context, method, initialURL string) ([]byte, error)
   ```
   - Start with initialURL
   - Parse response for @odata.nextLink
   - If nextLink exists, fetch that page and accumulate results
   - Return combined JSON array

   OR simpler approach - update each fetch function to loop:

3. In GetEligibleRoles:
   - After initial fetch, check for NextLink
   - While NextLink != "", fetch next page and append to result.Value

4. In GetActiveRoles:
   - Same pagination pattern

5. In GetEligibleGroups:
   - Same pagination pattern

6. In GetActiveGroups:
   - Same pagination pattern

Note: ARM API pagination in lighthouse.go uses different pattern (@odata.nextLink in JSON).
For now, focus on PIM Governance API pagination. ARM API pagination is lower priority
as eligible roles rarely exceed 100 per user.
  </action>
  <verify>go build ./... succeeds; go vet ./... reports no issues</verify>
  <done>PIM API requests follow @odata.nextLink to fetch all pages</done>
</task>

<task type="auto">
  <name>Task 3: Verify performance improvement</name>
  <files>internal/azure/lighthouse.go</files>
  <action>
Add debug logging to measure improvement:

1. In GetLighthouseSubscriptions, add timing logs:
   - Log number of unique tenants vs total subscriptions
   - Example: "Fetching names for %d unique tenants (from %d subscriptions)"

2. Ensure existing progress indication (spinner) still works during:
   - Subscription details fetching
   - Tenant name fetching
   - Active role assignment fetching

3. Run manual test if possible:
   - Build and run the application
   - Observe lighthouse panel loading time
   - Check activity log for tenant cache messages
  </action>
  <verify>go build ./... succeeds; application runs without errors</verify>
  <done>Debug logging shows cache efficiency; application performance improved</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go vet ./...` reports no issues
- [ ] Code follows existing patterns (sync.WaitGroup for parallel work)
- [ ] Tenant cache is used before subscription loop processes tenants
- [ ] NextLink field added to PIM response types
- [ ] Pagination loop implemented in GetEligibleRoles and GetEligibleGroups
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Tenant names fetched once per unique tenant
- PIM APIs follow pagination links
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-optimization/03-01-SUMMARY.md`
</output>
