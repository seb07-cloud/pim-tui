---
phase: 03-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/azure/lighthouse.go
autonomous: true

must_haves:
  truths:
    - "Tenant names are cached and reused across subscriptions"
    - "Each unique tenant ID results in only one API call"
    - "Subscription loading is faster for users with multiple subscriptions from same tenant"
  artifacts:
    - path: "internal/azure/lighthouse.go"
      provides: "Tenant name caching before subscription loop"
      contains: "tenantCache"
  key_links:
    - from: "GetLighthouseSubscriptions"
      to: "tenantCache lookup"
      via: "cache before API call"
      pattern: "tenantCache\\[.*\\]"
---

<objective>
Implement tenant name caching to reduce redundant API calls during subscription loading.

Purpose: Users with multiple subscriptions from the same tenant currently make duplicate tenant name lookups. Caching eliminates these redundant calls, improving load time.
Output: Optimized lighthouse.go with tenant name cache.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

@internal/azure/lighthouse.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Collect unique tenant IDs before fetching names</name>
  <files>internal/azure/lighthouse.go</files>
  <action>
    Modify GetLighthouseSubscriptions to:

    1. First pass: Fetch all subscription details to collect unique tenant IDs
       - Current code fetches subscription details AND tenant name in same goroutine
       - Separate these: first collect all tenant IDs, then fetch unique tenant names

    2. Build a set of unique tenant IDs from all subscriptions

    3. Create a tenant name cache: map[string]string (tenantID -> displayName)

    Current structure (lines 270-307):
    ```go
    for subID := range subMap {
        go func(id string) {
            // Fetch subscription details
            // Then immediately fetch tenant name
        }(subID)
    }
    ```

    New structure:
    ```go
    // Phase 1: Fetch subscription details and collect tenant IDs
    tenantIDs := make(map[string]bool)
    for subID := range subMap {
        go func(id string) {
            if details, err := c.getSubscriptionDetails(ctx, id); err == nil {
                tenantID := details.HomeTenantID
                if tenantID == "" {
                    tenantID = details.TenantID
                }
                mu.Lock()
                subMap[id].TenantID = tenantID
                tenantIDs[tenantID] = true
                mu.Unlock()
            }
        }(subID)
    }
    wg.Wait()

    // Phase 2: Fetch tenant names for unique tenant IDs only
    tenantCache := make(map[string]string)
    for tenantID := range tenantIDs {
        go func(tid string) {
            if name, err := c.getTenantNameByID(ctx, tid); err == nil && name != "" {
                mu.Lock()
                tenantCache[tid] = name
                mu.Unlock()
            }
        }(tenantID)
    }
    wg.Wait()

    // Phase 3: Apply cached tenant names to subscriptions
    for _, sub := range subMap {
        if name, ok := tenantCache[sub.TenantID]; ok {
            sub.TenantName = name
        } else {
            sub.TenantName = getTenantDisplayName(sub.TenantID, nil)
        }
    }
    ```
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Tenant names cached and reused, no duplicate API calls per tenant</done>
</task>

<task type="auto">
  <name>Task 2: Add pagination support for role eligibility response</name>
  <files>internal/azure/lighthouse.go</files>
  <action>
    Add @odata.nextLink handling to GetLighthouseSubscriptions.

    1. Parse `nextLink` from roleEligibilityResponse:
       ```go
       type roleEligibilityResponse struct {
           Value    []struct{ ... } `json:"value"`
           NextLink string          `json:"@odata.nextLink"`
       }
       ```

    2. Loop while NextLink is not empty:
       ```go
       allEligible := make([]eligibleItem, 0)
       reqURL := initialURL

       for reqURL != "" {
           data, err := c.armRequest(ctx, "GET", reqURL)
           if err != nil {
               return nil, err
           }

           var result roleEligibilityResponse
           if err := json.Unmarshal(data, &result); err != nil {
               return nil, err
           }

           allEligible = append(allEligible, result.Value...)
           reqURL = result.NextLink
       }
       ```

    3. Process allEligible instead of result.Value

    Note: Azure typically returns 100 items per page. This handles users with 100+ eligible roles.
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Pagination handles large result sets gracefully</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] Tenant cache logic implemented
- [ ] NextLink pagination implemented
- [ ] No duplicate tenant API calls possible
</verification>

<success_criteria>
- All tasks completed
- Tenant names cached before subscription processing
- Pagination support added for large result sets
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-optimization/03-01-SUMMARY.md`
</output>
