---
phase: 09-in-app-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/azure/client.go
  - internal/ui/model.go
  - internal/ui/views.go
  - internal/ui/keys.go
autonomous: false

must_haves:
  truths:
    - "User sees friendly login prompt when not authenticated (not error screen)"
    - "User can press L to start device code login flow"
    - "User sees device code and URL to complete authentication"
    - "App detects successful authentication and continues loading"
    - "App loads data normally after in-app authentication"
  artifacts:
    - path: "internal/azure/client.go"
      provides: "AuthenticateWithDeviceCode method"
      contains: "DeviceCodeCredential"
    - path: "internal/ui/model.go"
      provides: "StateUnauthenticated state and auth message types"
      contains: "StateUnauthenticated"
    - path: "internal/ui/views.go"
      provides: "renderUnauthenticated view with login instructions"
      contains: "renderUnauthenticated"
  key_links:
    - from: "model.go initClientCmd"
      to: "StateUnauthenticated"
      via: "auth error detection"
      pattern: "StateUnauthenticated"
    - from: "views.go renderUnauthenticated"
      to: "authCodeMsg"
      via: "device code display"
      pattern: "deviceCode"
    - from: "client.go AuthenticateWithDeviceCode"
      to: "model.go clientReadyMsg"
      via: "successful auth completion"
      pattern: "clientReadyMsg"
---

<objective>
Implement in-app authentication allowing users to log in via device code flow without restarting the app.

Purpose: Users who haven't run `az login` or whose session expired can authenticate directly from within pim-tui, improving UX by eliminating the need to exit and restart.

Output: Working device code authentication flow integrated with Bubble Tea UI.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 established the azidentity patterns we'll extend:
@.planning/phases/01-native-rest-migration/01-01-SUMMARY.md

# Current authentication implementation:
@internal/azure/client.go
@internal/ui/model.go
@internal/ui/views.go
@internal/ui/keys.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add device code authentication to Azure client</name>
  <files>internal/azure/client.go</files>
  <action>
Add a new method to enable device code authentication that integrates with Bubble Tea's message system.

1. Add a new function type for the device code callback:
   ```go
   // DeviceCodeCallback is called when a device code is received
   // The callback should display the message to the user
   type DeviceCodeCallback func(message string) error
   ```

2. Add `AuthenticateWithDeviceCode` method to Client:
   ```go
   // AuthenticateWithDeviceCode performs device code authentication flow.
   // The callback is invoked with the user instructions (URL and code).
   // Returns a new Client on success, or error on failure/timeout.
   func AuthenticateWithDeviceCode(ctx context.Context, callback DeviceCodeCallback) (*Client, error)
   ```

3. Implementation approach:
   - Use `azidentity.NewDeviceCodeCredential` with `DeviceCodeCredentialOptions`
   - Set `UserPrompt` to call the provided callback with `message.Message`
   - Use empty string for TenantID and ClientID to use defaults (Microsoft Azure CLI app ID)
   - After credential creation, call `cred.GetToken()` to trigger the auth flow
   - On success, create and return a new Client with the credential
   - Use the same Graph API scope as NewClient for token request

4. Important details:
   - DO NOT set TenantID - let Azure determine from user login (multi-tenant support)
   - DO NOT set ClientID - use Azure CLI's well-known client ID (default behavior)
   - The UserPrompt callback runs in a goroutine, so it can block waiting for user auth
   - Context cancellation should abort the auth flow
  </action>
  <verify>go build ./... compiles without errors</verify>
  <done>AuthenticateWithDeviceCode method exists and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Add StateUnauthenticated and auth message flow</name>
  <files>internal/ui/model.go, internal/ui/keys.go</files>
  <action>
Add UI state and message types for the authentication flow.

1. Add new state constant after StateError:
   ```go
   StateUnauthenticated // User needs to authenticate (not an error, a prompt)
   ```

2. Add new message types:
   ```go
   // authCodeMsg carries the device code message for display
   type authCodeMsg struct {
       message string // The full message with URL and code
   }

   // authCompleteMsg signals authentication completed
   type authCompleteMsg struct {
       client *azure.Client
       err    error
   }
   ```

3. Modify `initClientCmd()` to detect auth failures and return appropriate message:
   - If `azure.NewClient()` fails with auth error, return a marker that triggers StateUnauthenticated
   - Create new message type `authRequiredMsg struct{}` for this purpose
   - Keep existing behavior for other errors (StateError)

4. Add `startAuthCmd()` function that:
   - Creates a channel to receive device code messages
   - Calls `azure.AuthenticateWithDeviceCode` with a callback that sends to the channel
   - Uses `tea.Batch` to return both the auth command and a listener for code messages
   - Returns `authCompleteMsg` with client on success or error on failure

5. Handle new messages in `Update()`:
   - `authRequiredMsg`: Set `m.state = StateUnauthenticated`, clear error
   - `authCodeMsg`: Store message in model for display (add `deviceCodeMessage string` field)
   - `authCompleteMsg`: If success, set client and transition to loading; if error, show error

6. Handle key press in StateUnauthenticated:
   - 'l' or 'L': Start auth flow (`m.state = StateAuthenticating`, return `startAuthCmd()`)
   - 'q': Quit
   - Add new state `StateAuthenticating` for while auth is in progress

7. In keys.go, add keybinding for login ('l') visible in unauthenticated state.

Note: The device code flow is async - we start it, display the code, and wait for completion.
Use a separate goroutine with channel communication to bridge the callback to tea.Cmd.
  </action>
  <verify>go build ./... compiles without errors</verify>
  <done>StateUnauthenticated state and all auth messages defined and handled</done>
</task>

<task type="auto">
  <name>Task 3: Add unauthenticated view and integrate flow</name>
  <files>internal/ui/views.go, internal/ui/model.go</files>
  <action>
Create the UI view for unauthenticated state and ensure the flow works end-to-end.

1. Add `renderUnauthenticated()` method to views.go:
   - Display ASCII logo (same as loading/error screens)
   - Show friendly message: "Authentication Required"
   - Explain: "No Azure CLI session found. You can authenticate directly from this app."
   - If `m.deviceCodeMessage` is set, display it prominently (this contains URL and code)
   - If authenticating (StateAuthenticating), show spinner with "Waiting for browser authentication..."
   - Show keybindings: [L] Login  [Q] Quit
   - Use consistent styling with other screens (highlightBoldStyle, dimStyle, etc.)

2. Update `View()` function to handle new states:
   - Add case for `StateUnauthenticated` before StateError check
   - Add case for `StateAuthenticating` (show auth-in-progress view)

3. Add `deviceCodeMessage` field to Model struct if not already done in Task 2.

4. Add `StateAuthenticating` constant if not already done in Task 2.

5. Ensure StateAuthenticating view:
   - Shows the device code message prominently if available
   - Shows instructions: "Complete sign-in in your browser"
   - Shows spinner indicating we're waiting
   - Allows 'q' to quit (and cancel auth context)

6. Update error detection in initClientCmd:
   - Check for auth-related errors (contains "credential", "login", "authenticate", "token")
   - Return `authRequiredMsg{}` for auth errors
   - Return `errMsg{err, "auth"}` for other fatal errors

7. Handle context cancellation properly:
   - If user presses 'q' during StateAuthenticating, cancel the auth context
   - Add cancel func to model if needed
  </action>
  <verify>go build ./... compiles without errors</verify>
  <done>Unauthenticated view renders correctly and flow is integrated</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>In-app device code authentication flow</what-built>
  <how-to-verify>
    1. Ensure you're NOT logged in: `az logout`
    2. Run: `go run ./cmd/pim-tui`
    3. Verify: App shows "Authentication Required" screen (not error crash)
    4. Verify: Screen shows [L] Login and [Q] Quit options
    5. Press 'L' to start login
    6. Verify: Device code and URL are displayed
    7. Open the URL in browser, enter the code, complete login
    8. Verify: App automatically detects login and proceeds to loading
    9. Verify: App loads data and shows normal interface
    10. Optional: Test 'Q' quit during auth flow
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` compiles without errors
- [ ] `go test ./...` passes (existing tests still work)
- [ ] App shows friendly prompt when not authenticated (not error)
- [ ] Device code flow starts on 'L' key press
- [ ] Device code message displays correctly
- [ ] Successful auth transitions to loading state
- [ ] App works normally after in-app authentication
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- User can authenticate from within the app
- App handles both authenticated and unauthenticated startup gracefully
- Device code flow works for non-interactive terminals
</success_criteria>

<output>
After completion, create `.planning/phases/09-in-app-authentication/09-01-SUMMARY.md`
</output>
