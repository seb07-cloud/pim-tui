---
phase: 04-ui-scrolling-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/ui/model.go
  - internal/ui/views.go
autonomous: false

must_haves:
  truths:
    - "Scrolling in one panel does not affect other panels"
    - "Each panel maintains independent scroll position"
    - "Panel headers remain visible during scroll"
    - "Scroll position preserved when switching tabs"
  artifacts:
    - path: "internal/ui/model.go"
      provides: "Independent scroll offsets per panel"
      contains: "rolesScrollOffset"
    - path: "internal/ui/views.go"
      provides: "Fixed panel rendering with content scrolling"
  key_links:
    - from: "Model scroll offsets"
      to: "view rendering"
      via: "offset applied to content slice"
---

<objective>
Fix UI scrolling so panels stay fixed and only content scrolls within each panel.

Purpose: Currently scrolling in one panel causes all panels to shift position, which is disorienting. Users expect panels to stay fixed while content scrolls independently.
Output: Independent scroll behavior for Roles, Groups, and Lighthouse panels.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

@internal/ui/model.go
@internal/ui/views.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add independent scroll offset tracking per panel</name>
  <files>internal/ui/model.go</files>
  <action>
    Add scroll offset fields to Model struct:

    ```go
    // In Model struct, add near cursor fields:
    rolesScrollOffset  int
    groupsScrollOffset int
    lightScrollOffset  int
    ```

    Modify cursor movement handlers to update scroll offset:
    - When cursor moves beyond visible area, adjust scroll offset
    - Calculate visible items based on panel height
    - Keep cursor within visible window

    The key insight: cursor position is absolute (0 to len-1), but scroll offset determines which slice of items is rendered.

    Example logic:
    ```go
    // Calculate visible window
    visibleItems := panelHeight - headerHeight

    // Ensure cursor is within visible window
    if cursor < scrollOffset {
        scrollOffset = cursor  // Scroll up
    } else if cursor >= scrollOffset + visibleItems {
        scrollOffset = cursor - visibleItems + 1  // Scroll down
    }
    ```
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Scroll offsets tracked independently for each panel</done>
</task>

<task type="auto">
  <name>Task 2: Modify panel rendering to use scroll offsets</name>
  <files>internal/ui/views.go</files>
  <action>
    Modify renderRolesPanel, renderGroupsPanel, and renderLighthousePanel to:

    1. Calculate available content height (panel height minus header)
    2. Slice the items array using scroll offset:
       ```go
       start := scrollOffset
       end := min(start + visibleItems, len(items))
       visibleSlice := items[start:end]
       ```
    3. Render only the visible slice
    4. Adjust item indices for selection display (add offset)

    For the header, ensure it's rendered OUTSIDE the scrollable area:
    ```go
    func (m Model) renderRolesPanel() string {
        // Fixed header (always visible)
        header := renderPanelHeader("Roles", len(m.roles), m.activeTab == TabRoles)

        // Scrollable content
        contentHeight := m.panelHeight - lipgloss.Height(header)
        start := m.rolesScrollOffset
        end := min(start + contentHeight, len(m.roles))

        var items []string
        for i := start; i < end; i++ {
            // Render each item (i is absolute index for selection)
            items = append(items, renderRoleItem(m.roles[i], m.rolesCursor == i, m.selectedRoles[i]))
        }

        content := lipgloss.JoinVertical(lipgloss.Left, items...)
        return lipgloss.JoinVertical(lipgloss.Left, header, content)
    }
    ```
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Panels render fixed headers with scrollable content</done>
</task>

<task type="auto">
  <name>Task 3: Preserve scroll position when switching tabs</name>
  <files>internal/ui/model.go</files>
  <action>
    Ensure tab switching does NOT reset scroll offsets.

    Current tab switch logic should already preserve offsets if they're stored in Model (not recalculated on render).

    Verify:
    1. Switch to Roles tab, scroll down
    2. Switch to Groups tab
    3. Switch back to Roles tab
    4. Scroll position should be preserved

    If offsets are being reset, find where and fix.
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Scroll position preserved across tab switches</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Independent panel scrolling with fixed headers</what-built>
  <how-to-verify>
    1. Run: go build ./... && ./pim-tui (or go run ./cmd/pim-tui)
    2. Wait for data to load
    3. In Roles panel: Press j/down multiple times to scroll
    4. Verify: Groups and Lighthouse panels stay in place
    5. Switch to Groups tab (Tab key)
    6. Scroll in Groups panel
    7. Verify: Roles panel position unchanged
    8. Switch back to Roles tab
    9. Verify: Previous scroll position restored
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] Each panel has independent scroll offset
- [ ] Panel headers stay fixed during scroll
- [ ] Scroll position preserved on tab switch
- [ ] Human verified scrolling behavior
</verification>

<success_criteria>
- All tasks completed
- Scrolling in one panel doesn't affect others
- Headers remain visible
- User approved visual behavior
</success_criteria>

<output>
After completion, create `.planning/phases/04-ui-scrolling-fix/04-01-SUMMARY.md`
</output>
