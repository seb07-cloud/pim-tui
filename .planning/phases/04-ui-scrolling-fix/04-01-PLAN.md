---
phase: 04-ui-scrolling-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/ui/model.go
  - internal/ui/views.go
autonomous: false

must_haves:
  truths:
    - "Scrolling in Roles panel does not move Groups or Subscriptions panels"
    - "Scrolling in Groups panel does not move Roles or Subscriptions panels"
    - "Scrolling in Subscriptions panel does not move other panels"
    - "Each panel maintains its scroll position when switching tabs"
    - "Panel headers remain visible while content scrolls"
  artifacts:
    - path: "internal/ui/model.go"
      provides: "Independent scroll offset fields per panel"
      contains: "rolesScrollOffset"
    - path: "internal/ui/views.go"
      provides: "Scroll-aware list rendering using stored offsets"
      contains: "rolesScrollOffset"
  key_links:
    - from: "model.go scroll fields"
      to: "views.go render functions"
      via: "m.rolesScrollOffset passed to render"
    - from: "handleKeyPress up/down"
      to: "scroll offset update"
      via: "moveCursor adjusts offset when cursor moves"
---

<objective>
Fix UI scrolling so each panel maintains independent scroll position.

Purpose: Currently scroll position is derived from cursor position on each render, which works but doesn't preserve scroll position when switching tabs. Add persistent scroll offsets per panel that are updated during navigation and preserved across tab switches.

Output: Model with scroll offset fields, render functions that use stored offsets, cursor navigation that updates offsets.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@internal/ui/model.go
@internal/ui/views.go
@internal/ui/styles.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scroll offset fields to Model</name>
  <files>internal/ui/model.go</files>
  <action>
Add independent scroll offset fields to the Model struct for each list panel:

```go
// In Model struct, after the existing cursor fields
rolesScrollOffset  int // Scroll offset for roles list
groupsScrollOffset int // Scroll offset for groups list
lightScrollOffset  int // Scroll offset for lighthouse/subscriptions list
```

These fields persist the scroll position independently from cursor position. The scroll offset represents the index of the first visible item in the list.

Update `moveCursor()` to adjust scroll offsets:
- When cursor moves beyond visible window, adjust scroll offset to keep cursor visible
- Calculate visible window as: startIdx = scrollOffset, endIdx = scrollOffset + displayHeight
- If cursor < startIdx, set scrollOffset = cursor (scroll up)
- If cursor >= endIdx, set scrollOffset = cursor - displayHeight + 1 (scroll down)

Update `clearSelections()` to optionally NOT reset scroll offsets (keep them as-is since clearing selections doesn't mean we want to lose scroll position).

Initialize scroll offsets to 0 in NewModel (they default to 0 anyway but be explicit).
  </action>
  <verify>go build ./... succeeds without errors</verify>
  <done>Model has rolesScrollOffset, groupsScrollOffset, lightScrollOffset fields; moveCursor updates scroll offsets when cursor moves beyond visible window</done>
</task>

<task type="auto">
  <name>Task 2: Update list render functions to use stored scroll offsets</name>
  <files>internal/ui/views.go</files>
  <action>
Modify `renderItemListWithExpiry` to accept and use a scroll offset parameter instead of calculating scroll position from cursor:

1. Change function signature to accept scrollOffset:
```go
func (m Model) renderItemListWithExpiry(height int, itemType string, count int, scrollOffset int, getItem func(int) ...) string
```

2. Replace the scroll window calculation logic:
- Old: Calculate startIdx by centering cursor in view
- New: Use scrollOffset directly as startIdx, clamp to valid range

3. Update calls to renderItemListWithExpiry:
- renderRolesList: pass m.rolesScrollOffset
- renderGroupsList: pass m.groupsScrollOffset

4. Update renderSubscriptionsList similarly:
- Use m.lightScrollOffset instead of calculating from cursor position
- The cursorVisibleIdx calculation stays (for position indicator) but window start uses stored offset

Ensure scroll indicators (↑↓) still show based on whether there's content above/below the visible window.
  </action>
  <verify>go build ./... succeeds; scroll indicators display correctly</verify>
  <done>List render functions use stored scroll offsets; scroll window is consistent with stored offset values</done>
</task>

<task type="auto">
  <name>Task 3: Ensure scroll position preserved on tab switch</name>
  <files>internal/ui/model.go</files>
  <action>
Verify that tab switching (Tab key, left/right arrows) does NOT reset scroll offsets.

In handleKeyPress, check the "tab", "left", "right" cases:
- Tab should only change m.activeTab, NOT touch any scroll offset
- Left/Right should only change m.activeTab, NOT touch any scroll offset

The existing code likely already does this (it only changes activeTab), but verify and add a comment:
```go
case "tab":
    // Switch tabs - scroll offsets preserved independently
    m.activeTab = (m.activeTab + 1) % 3
    m.subRoleFocus = false
```

Also verify the scroll offset is preserved during:
- Search activation/deactivation (escape to clear search)
- Refresh operations (r key)
- After activation/deactivation completes

The scroll offsets should only change when:
1. User navigates up/down within a list (cursor moves beyond visible window)
2. Data reloads and the list becomes shorter than the scroll offset (clamp offset to valid range)

Add clamping in the data load handlers (rolesLoadedMsg, groupsLoadedMsg, lighthouseLoadedMsg):
```go
case rolesLoadedMsg:
    m.roles = msg.roles
    m.rolesLoaded = true
    // Clamp scroll offset if list got shorter
    if m.rolesScrollOffset >= len(m.roles) {
        m.rolesScrollOffset = max(0, len(m.roles)-1)
    }
```
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Scroll offsets preserved when switching tabs; offsets clamped when data reloads with fewer items</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Independent scroll offsets per panel with preserved scroll position across tab switches</what-built>
  <how-to-verify>
    1. Run: go run ./cmd/pim-tui
    2. Wait for data to load (roles, groups, subscriptions)
    3. Test scroll preservation:
       a. In Roles tab, scroll down several items (press j/down multiple times)
       b. Press Tab to switch to Groups tab
       c. Press Tab again to return to Roles tab
       d. VERIFY: Roles list shows same scroll position as before (not reset to top)
    4. Test independent scrolling:
       a. In Roles tab, scroll to middle of list
       b. Switch to Groups tab, scroll to bottom of list
       c. Switch to Subscriptions tab, stay at top
       d. Switch back to Roles tab
       e. VERIFY: Each tab shows its own scroll position
    5. Test panel stability:
       a. In any tab, scroll up and down rapidly
       b. VERIFY: Panel headers stay fixed, only content area scrolls
       c. VERIFY: Other panels (header, log panel, status bar) don't move
    6. Test edge cases:
       a. Scroll to bottom of a list, then press refresh (r)
       b. VERIFY: After refresh, scroll position is preserved or clamped if list is shorter
  </how-to-verify>
  <resume-signal>Type "approved" if scrolling works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go vet ./...` reports no issues
- [ ] Each panel maintains independent scroll offset
- [ ] Scroll position preserved when switching tabs
- [ ] Scroll position clamped appropriately when data reloads
- [ ] Human verification of visual behavior passes
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Scroll offset fields added to Model
- List render functions use stored scroll offsets
- Tab switching preserves scroll positions
- Human verified visual behavior is correct
</success_criteria>

<output>
After completion, create `.planning/phases/04-ui-scrolling-fix/04-01-SUMMARY.md`
</output>
