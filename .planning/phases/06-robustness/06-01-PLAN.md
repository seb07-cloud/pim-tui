---
phase: 06-robustness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/pim-tui/main.go
  - internal/ui/model.go
autonomous: true

must_haves:
  truths:
    - "Ctrl+C exits cleanly without hanging"
    - "Justification input rejects control characters"
    - "Justification input enforces character limit"
  artifacts:
    - path: "cmd/pim-tui/main.go"
      provides: "Signal handling for graceful shutdown"
      contains: "signal.Notify"
    - path: "internal/ui/model.go"
      provides: "Input validation for justification"
      contains: "validateJustification"
  key_links:
    - from: "main()"
      to: "signal handler"
      via: "os/signal.Notify"
    - from: "justification input"
      to: "validation"
      via: "validateJustification before activation"
---

<objective>
Add graceful shutdown handling and input validation for robustness.

Purpose: Users expect Ctrl+C to exit cleanly. Justification should be validated before sending to Azure API.
Output: Robust application with proper signal handling and input validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

@cmd/pim-tui/main.go
@internal/ui/model.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add graceful shutdown signal handling</name>
  <files>cmd/pim-tui/main.go</files>
  <action>
    Add signal handling for SIGINT and SIGTERM:

    ```go
    package main

    import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        tea "github.com/charmbracelet/bubbletea"

        "github.com/seb07-cloud/pim-tui/internal/config"
        "github.com/seb07-cloud/pim-tui/internal/ui"
    )

    var version = "0.1.0"

    func main() {
        cfg, err := config.Load()
        if err != nil {
            fmt.Fprintf(os.Stderr, "Warning: failed to load config: %v\n", err)
        }

        // Set up context with cancellation for graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle interrupt signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

        go func() {
            <-sigChan
            cancel()
        }()

        m := ui.NewModel(cfg, version)
        p := tea.NewProgram(m, tea.WithAltScreen(), tea.WithContext(ctx))

        if _, err := p.Run(); err != nil {
            // Don't print error on clean interrupt
            if ctx.Err() == nil {
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
            }
        }
    }
    ```

    The `tea.WithContext(ctx)` option tells Bubble Tea to respect context cancellation.
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Ctrl+C/SIGTERM triggers clean exit</done>
</task>

<task type="auto">
  <name>Task 2: Add justification input validation</name>
  <files>internal/ui/model.go</files>
  <action>
    Add validation function and apply before activation:

    1. Add validateJustification helper:
       ```go
       // validateJustification checks justification text for issues
       // Returns cleaned text and any validation error
       func validateJustification(text string) (string, error) {
           // Remove control characters (keep newlines for multi-line)
           cleaned := strings.Map(func(r rune) rune {
               if r == '\n' || r == '\r' || r == '\t' {
                   return r
               }
               if r < 32 || r == 127 {
                   return -1 // Remove control characters
               }
               return r
           }, text)

           // Trim whitespace
           cleaned = strings.TrimSpace(cleaned)

           // Check length (Azure PIM typically has 500 char limit)
           const maxLength = 500
           if len(cleaned) > maxLength {
               return "", fmt.Errorf("justification too long: %d characters (max %d)", len(cleaned), maxLength)
           }

           // Check minimum length
           if len(cleaned) == 0 {
               return "", fmt.Errorf("justification cannot be empty")
           }

           return cleaned, nil
       }
       ```

    2. Apply validation in startActivation or before calling activation APIs:
       ```go
       justification, err := validateJustification(m.justificationInput.Value())
       if err != nil {
           m.log(LogError, "Invalid justification: %v", err)
           // Return to justification input state with error message
           return m, nil
       }
       ```

    3. Display validation error to user (show message in justification dialog).
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Justification validated for length and control characters</done>
</task>

<task type="auto">
  <name>Task 3: Show validation feedback in UI</name>
  <files>internal/ui/model.go, internal/ui/views.go</files>
  <action>
    Add a validationError field to Model and display in justification view:

    1. In Model struct:
       ```go
       validationError string // Current validation error message
       ```

    2. Clear validation error when entering justification state:
       ```go
       m.validationError = ""
       ```

    3. Set validation error on validation failure:
       ```go
       if err != nil {
           m.validationError = err.Error()
           return m, nil  // Stay in justification state
       }
       ```

    4. In renderJustification view, display error if present:
       ```go
       if m.validationError != "" {
           errorLine := errorStyle.Render("Error: " + m.validationError)
           // Add to dialog
       }
       ```
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Validation errors displayed to user</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] Signal handling uses os/signal
- [ ] validateJustification function exists
- [ ] Validation error displays in justification dialog
- [ ] Control characters are stripped from input
</verification>

<success_criteria>
- All tasks completed
- Ctrl+C exits cleanly
- Invalid justification shows error message
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06-robustness/06-01-SUMMARY.md`
</output>
